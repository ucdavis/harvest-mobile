# Harvest Mobile - Copilot Instructions

You are an expert mobile app developer working on the **Harvest Mobile** project. This is a React Native application built with Expo Router for time tracking and expense management.

## Project Overview

- **Framework**: React Native with Expo SDK 53
- **Router**: Expo Router (file-based routing)
- **Styling**: NativeWind (Tailwind CSS for React Native)
- **State Management**: React Context + TanStack Query
- **Database**: Expo SQLite
- **Authentication**: Expo Auth Session + Secure Store
- **UI Components**: Custom components with Tailwind styling
- **TypeScript**: Fully typed codebase

## Architecture Patterns

### File Structure Standards

- **`/app`**: File-based routing with Expo Router
- **`/components`**: Reusable UI components and contexts
- **`/lib`**: Business logic and database operations
- **`/services`**: API clients and external service integrations
- **`/hooks`**: Custom React hooks
- **`/constants`**: App-wide constants and theme definitions

### Component Organization

```
components/
  ├── context/          # React Context providers
  ├── ui/              # Pure UI components
  ├── [feature]/       # Feature-specific components (e.g., projects/, rates/)
  └── [ComponentName]  # Shared utility components
```

### Routing Structure

- Uses Expo Router with file-based routing
- Tab-based navigation in `(tabs)` directory
- Modal screens at root level
- Authentication handled in root `_layout.tsx`

## Code Style & Conventions

Don't create `index.ts` files. Instead, use direct file imports for clarity.

### TypeScript Standards

- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use proper typing for React components and hooks
- Leverage type inference where appropriate

### Component Patterns

```tsx
// Preferred component structure
export default function ComponentName({ prop1, prop2 }: Props) {
  // 1. Hooks and state
  // 2. Effects and callbacks
  // 3. Event handlers
  // 4. Render helpers
  // 5. Main render
}

interface Props {
  prop1: string;
  prop2?: number;
}
```

### Styling with NativeWind

- Use Tailwind utility classes via `className` prop
- Custom brand colors defined in `tailwind.config.js`:
  - `harvest` (#266041) - Primary brand color
  - `secondary-bg` (#F7F7F7) - Background gray
  - `primary-font` (#1F1F1F) - Text color
  - `primary-border` (#DFDFDF) - Border color
  - `danger` (#79242F) - Error/danger color

### Context Usage

- **AuthContext**: User authentication state and login/logout functions
- **ExpenseContext**: Expense data and operations
- **QueryContext**: TanStack Query client provider

## Development Guidelines

### Data Management

- Use TanStack Query for server state management
- Use React Context for app-wide state
- Store sensitive data with Expo SecureStore
- Use Expo SQLite for local data persistence

### Navigation

- Use `expo-router` for navigation
- Implement proper TypeScript typing for route parameters
- Use `href` prop for navigation links
- Handle deep linking through `expo-linking`

### API Integration

- Centralize API calls in `/services` directory
- Use TanStack Query for caching and synchronization
- Implement proper error handling and loading states
- Use async/await pattern consistently

### Database Operations

- Database client in `/lib/db/client.ts`
- Business logic in `/lib` directory (auth.ts, expense.ts, project.ts)
- Use prepared statements for security
- Handle database migrations properly

## Key Dependencies to Remember

### Core Dependencies

- `expo` - Expo SDK
- `expo-router` - File-based routing
- `react-native` - React Native framework
- `nativewind` - Tailwind CSS for React Native

### State & Data

- `@tanstack/react-query` - Server state management
- `expo-sqlite` - Local database
- `expo-secure-store` - Secure storage

### Authentication & Security

- `expo-auth-session` - OAuth authentication
- `expo-crypto` - Cryptographic functions

### UI & UX

- `expo-haptics` - Haptic feedback
- `react-native-gesture-handler` - Gesture handling
- `react-native-reanimated` - Animations
- `react-native-heroicons` - Icon library

## Common Tasks & Patterns

### Adding New Screens

1. Create file in `/app` directory following Expo Router conventions
2. Use proper TypeScript typing for route parameters
3. Implement proper loading and error states
4. Follow established component structure

### Creating Components

1. Place in appropriate `/components` subdirectory
2. Use TypeScript interfaces for props
3. Apply consistent styling with NativeWind
4. Export as default when single component per file

### API Integration

1. Define queries in `/services/queries`
2. Use TanStack Query hooks in components
3. Handle loading, error, and success states
4. Implement proper data transformation

### Database Operations

1. Add functions to appropriate `/lib` file
2. Use type-safe database operations
3. Handle errors gracefully
4. Consider database schema updates

## Brand & Design System

### Colors

- Primary: `#266041` (harvest green)
- Secondary Background: `#F7F7F7`
- Text: `#1F1F1F`
- Borders: `#DFDFDF`
- Danger: `#79242F`

### Typography

- Primary font: Proxima Nova (loaded via expo-font)
- Monospace: Space Mono

### UI Patterns

- Use consistent spacing with Tailwind utilities
- Implement proper accessibility labels
- Follow iOS and Android design guidelines
- Maintain consistent component sizing

## Performance Considerations

- Use React.memo() for expensive components
- Implement proper list virtualization for large datasets
- Optimize images with expo-image
- Use Expo development builds for testing
- Monitor bundle size and loading performance

## Security Best Practices

- Store sensitive tokens in Expo SecureStore
- Validate all user inputs
- Use prepared statements for database queries
- Implement proper authentication flow
- Handle deep links securely

## Testing Approach

- Focus on component functionality
- Test navigation flows
- Validate data transformations
- Test authentication states
- Ensure offline functionality works

When working on this project, prioritize code quality, user experience, and maintainability. Always consider mobile-specific constraints like network connectivity, battery usage, and various screen sizes.
